# vue2 源码

> vue 的构造函数 instance -> index.js

```javascript
function Vue(options) {
  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

## 注册实例方法

- initMixin
  - \_init 函数的注册
- stateMixin
  - 为$data 和 $props 添加代理为 \_data \_props
  - 注册 $set $del $watch 函数
- eventsMixin
  - 注册 $on $emit $once 等发布订阅的函数
- lifecycleMixin
  - 注册 \_update 函数
- renderMixin
  - 注册 $nextTick 函数
  - 注册 \_render 函数

## new Vue() 做了什么

### 执行 \_init() 函数 在 initMixin 注册过的

- mergeOptions()
  - 合并 options , 不然 transition keep-alive component 这些组件为什么不用注册就直接能用 全局 direct filter 等被合并
  - 比如 v-show v-model
- initLifecycle()
  - $parent $root $children
- initEvents()
  - 自定义事件 发布订阅 处理组件上的事件监听
- initRender()
  - createElement 的初始化
  - $scopedSlots 的初始化 $slot 的初始化
  - $attrs $listeners 两个属性被 defineReactive 响应式处理
- callHook(vm, 'beforeCreate')
  - 触发生命周期 beforeCreate 函数
- initInjections()
  - 依赖注入 provide 并变为响应式
- initState()
  - props > methods > data > computed > watch
  - 会做代理 比如 this.xx 代理为 this.\_props.xx
  - 深层递归 data 变为响应式，依赖收集
- initProvide()
  - 初始化\_provided 熟悉以便上面的依赖注入使用
- callHook(vm, 'created')
  - 触发生命周期 created 函数
- vm.$options.el 
  - 如果有 el 则调用 $mount(vm.$options.el) 挂载
